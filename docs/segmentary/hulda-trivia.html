<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8"><!-- for emoji happiness-->
    <link rel='stylesheet'
        href='https://s3-us-west-1.amazonaws.com/patterns.esri.com/files/calcite-web/1.2.5/css/calcite-web.min.css'>

    <script type="module" src="https://js.arcgis.com/calcite-components/1.0.0-beta.76/calcite.esm.js"></script>
    <script nomodule="" src="https://js.arcgis.com/calcite-components/1.0.0-beta.76/calcite.js"></script>
    <link rel="stylesheet" type="text/css" href="https://js.arcgis.com/calcite-components/1.0.0-beta.76/calcite.css" />

    <link href="https://unpkg.com/tabulator-tables@5.1/dist/css/tabulator.min.css" rel="stylesheet">
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.1/dist/js/tabulator.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <style>
        body {
            padding: 1em;
        }
    </style>
</head>

<body>
    <h1>Hulda Trivia</h1>

    <p id="description"> </p>

    <p>
        <calcite-button appearance="solid" icon-end="forward" id="button1">Give me more Hulda Trivia!
        </calcite-button>
    </p>

    <ul id="trivialist">
    </ul>

    <p id="intro"></p>

    <script>
        (async () => {

            // START TRIVIA
            const descriptionDiv = document.getElementById('description');
            const trivialistElement = document.getElementById('trivialist');
            const areaname = "Hulda";

            const segmentsURL = areaname.toLocaleLowerCase() + "-segments.json"
            const athletesURL = areaname.toLocaleLowerCase() + "-athletes.json"
            const maxcase = 13; // for +1 factTypes
            let segments = [];
            let athleteData = [];
            let crowns2022 = [];
            let crowns = [];
            let names = [];
            let attempts = [];
            let peopleCounts = [];
            let count_everyones = [];
            let count_everyone_2022s = [];
            let wordCounts = []
            let segmentData = [];
            let possibleFacts = [
                'longDistance1',
                'longDistance2',
                'shortDistance1',
                'shortDistance2',
                '2022segmentcount',
                'not2022segmentcount',
                'averageDistance',
                'averageNameLength',
                'longName1',
                'longName2',
                'shortName1',
                'shortName2',
                'commonWord1',
                'commonWord2',
                'moreThan1000Runners',
                'moreThan500Runners',
                'moreThan100Runners',
                'huldacrooks1',
                'huldacrooks2',
                'oldestsegment',
                'burroSegments',
                'rabbitSegments',
                'burroFact1',
                'crowns2022',
                'crowns',
                'peopleWithCrowns',
                'peopleWithCrowns2022'
            ]
            //possibleFacts = ['peopleWithCrowns2022']; // crowns2022', 'crowns
            const maxFacts = possibleFacts.length;
            let factCount = 0;

            console.log(`~~~~~~~~~~~~~~~~ get ready for ${maxFacts} facts about ${areaname}.`)

            document.getElementById("button1").addEventListener("click", function () {
                getRandomFact("button clicked");
            });

            // grab the available HTML file names
            await axios.get(segmentsURL)
                .then(function (response) {
                    segmentData = response.data; // .body ; //JSON.parse(response.body);
                    descriptionDiv.innerHTML += `Random stats about the ${segmentData.length} segments in ${areaname}.`;
                    //response.forEach((stat, index) => {
                    segmentData.forEach((element, index) => {
                        if (element.name.match(/&#39;/)) {
                            element.name = element.name.replace(/&#39;/gi, "'");
                        }
                        segments.push(element.segment);
                        names.push(element.name);
                        attempts.push(element.attempts);
                        peopleCounts.push(element.peopleCount);
                        count_everyones.push(element.count_everyone);
                        if (element.count_everyone_2022 > 0) {
                            count_everyone_2022s.push(element.count_everyone_2022);
                        }
                        if (element.athletes) {
                            crowns.push(element.athletes[0]);
                            if (element.athletes_2022) {
                                crowns2022.push(element.athletes_2022[0]);
                            }
                        }
                    });

                    crowns.sort((a, b) => { return a.count > b.count ? -1 : 1 }); // most crows first
                    crowns2022.sort((a, b) => { return a.count > b.count ? -1 : 1 }); // most crows first
                    segments.sort(function (a, b) { return a - b }); // sort numbers in asc
                    names.sort();
                    attempts.sort(function (a, b) { return b - a });  // Sort numbers in descending order:
                    peopleCounts.sort(function (a, b) { return b - a });
                    count_everyones.sort(function (a, b) { return b - a });
                    count_everyone_2022s.sort(function (a, b) { return b - a });

                    // how common are different words in the segment names
                    const namesCombo = names.join(' ').toLocaleLowerCase();
                    const words = namesCombo.split(/\b/);
                    for (var i = 0; i < words.length; i++) {
                        if (words[i].match(/[A-z]/) && words[i].length > 0
                            && !words[i].match(/^the$/)
                            && !words[i].match(/^to$/)
                            && !words[i].match(/^of$/)
                            && !words[i].match(/^a$/)
                            && !words[i].match(/^an$/)
                            && !words[i].match(/^and$/)
                        ) {

                            const index = wordCounts.findIndex((obj => obj.word == words[i]));
                            if (index == -1) { //create
                                wordCounts.push({ 'word': words[i], 'count': 1 });
                            } else {
                                const temp = wordCounts[index].count
                                wordCounts[index].count = temp + 1;
                            }
                        }
                    }
                    wordCounts.sort(function (a, b) { return b.count - a.count });  // Sort numbers in descending order:
                })
                .catch(function (error) {
                    console.error("-------- error 101 ----------");
                    console.error(error);
                })
                .then(function () {
                    console.log(`~~~~~~~~~~~~~~~~ got data for ${segmentData.length} segments.`)
                });

            // end of axiom 1

            await axios.get(athletesURL)
                .then(function (response) {
                    athleteData = response.data; // .body ; //JSON.parse(response.body);
                    descriptionDiv.innerHTML += ` And its ${athleteData.length} runners.`;
                })
                .catch(function (error) {
                    console.error("-------- error 102 ----------");
                    console.error(error);
                })
                .then(function () {
                    console.log(`~~~~~~~~~~~~~~~~ got data for ${segmentData.length} segments.`)
                });

            // end of axiom 2

            function getRandomFact() {
                let fact = "";
                const lastFact = "<i>Enough trivia, why don't you go run instead?</i>";
                if (factCount++ == maxFacts) {
                    fact = lastFact;
                } else if (factCount > maxFacts) {
                    return;
                }

                if (possibleFacts.length > 0) {
                    const randomIndex1 = Math.floor(Math.random() * possibleFacts.length);
                    console.log("Now", possibleFacts[randomIndex1]);
                    const thisPossibleFact = possibleFacts.splice(randomIndex1, 1)[0];

                    switch (thisPossibleFact) {
                        case "longDistance1":
                            fact = getFactByField(1, "distance");
                            break;
                        case "longDistance2":
                            fact = getFactByField(2, "distance");
                            break;
                        case "shortDistance1":
                            fact = getFactByField(3, "distance");
                            break;
                        case "shortDistance2":
                            fact = getFactByField(4, "distance");
                            break;
                        case "averageDistance":
                            fact = `Average segment distance is ${findAverageDistance(segmentData)} miles`;
                            break;
                        case "averageNameLength":
                            fact = `Average segment name is ${findAverageNameLength(segmentData)} characters long`;
                            break;
                        case "2022segmentcount":
                            // how many segments run in 2022
                            fact = `${count_everyone_2022s.length} segments (${Math.round(100 * count_everyone_2022s.length / count_everyones.length)}%) have already been run by someone in 2022.`;
                            break;
                        case "not2022segmentcount":
                            const num2 = count_everyones.length - count_everyone_2022s.length;
                            fact = `${num2} segments (${Math.round(100 * num2 / count_everyones.length)}%) have not yet been run by anyone in 2022.`;
                            break;
                        case "longName1":
                            fact = getFactByField(1, "name");
                            break;
                        case 'longName2':
                            fact = getFactByField(2, "name");
                            break;
                        case "shortName1":
                            fact = getFactByField(3, "name");
                            break;
                        case "shortName2":
                            fact = getFactByField(4, "name");
                            break;
                        case "commonWord1":
                            fact = `The most common word in segment names is <b>${wordCounts[0].word}</b>.`;
                            break;
                        case "commonWord2":
                            fact = `The two most common words in segment names are <b>${wordCounts[0].word}</b> and <b>${wordCounts[1].word}</b>`;
                            break;
                        case 'moreThan1000Runners':
                            pCount = 1000;
                            const segs__moreThan1000Runners = segmentData.filter(seg => seg.peopleCount > pCount)
                            const count_moreThan1000Runners = segs__moreThan1000Runners.length;
                            if (count_moreThan1000Runners > 1) {
                                fact = `Only ${count_moreThan1000Runners} segments have been run by more than ${pCount} people`
                            } else if (count_moreThan1000Runners == 1) {
                                fact = `Only one segment have been run by more than ${pCount} people:
                                <a href="${segs__moreThan1000Runners[0].segment}">${segs__moreThan1000Runners[0].name}</a>`
                            } else {
                                fact = `No segments have been run by more than ${pCount} people`
                            }
                            break;
                        case 'moreThan500Runners':
                            pCount = 500;
                            fact = segmentData.filter(seg => seg.peopleCount > pCount).length + ` segments have been run by more than ${pCount} people`
                            break;
                        case 'moreThan100Runners':
                            pCount = 100;
                            fact = `More than ${pCount} people have run over ${segmentData.filter(seg => seg.peopleCount > pCount).length} segments in ${areaname}`
                            break;
                        case 'huldacrooks1':
                            fact = `<a href="https://en.wikipedia.org/wiki/Hulda_Crooks">Hulda Crooks</a> (1896-1997) was an awesome lady - check out <a href="https://diabetesdietdialogue.wordpress.com/2007/07/28/who-are-the-oldest-people-on-our-planet-and-why-are-they-that-healthy-part-6/">this article</a>`
                            break;
                        case 'huldacrooks2':
                            fact = `Hulda Crooks Park is named after <a href="https://en.wikipedia.org/wiki/Hulda_Crooks">Hulda Crooks</a> (1896-1997), aka "Grandma Whitney", and is also what most people call the whole <a href="https://www.lomalinda-ca.gov/common/pages/DisplayFile.aspx?itemId=7918026">South Hills Preserve</a> area`
                            break;
                        case 'oldestsegment':
                            segmentData.sort((a, b) => {
                                return a.segment - b.segment;  // lowest number first
                            });
                            fact = `The oldest segment is <a href="https://www.strava.com/segments/${segmentData[0].segment}">${segmentData[0].name}</a>`
                            break
                        case 'burroSegments':
                            const segs1 = segmentData.filter(seg => seg.name.toLowerCase().includes('burro') || seg.name.toLowerCase().includes('donkey'))
                            fact = segs1.length + ` segments with Burro-related names: `; //
                            segs1.forEach((element, index) => {
                                if (index == segs1.length - 1) {
                                    fact += ` and <a href="https://www.strava.com/segments/${element.segment}">${element.name}</a>`;
                                } else {
                                    fact += `<a href="https://www.strava.com/segments/${element.segment}">${element.name}</a>, `;
                                }
                            });
                            break;
                        case 'rabbitSegments':
                            const segs3 = segmentData.filter(seg => seg.name.toLowerCase().includes('rabbit') || seg.name.toLowerCase().includes('bunny'))
                            fact = segs3.length + ` segments with Rabbit-related names: `; //
                            segs3.forEach((element, index) => {
                                if (index == segs3.length - 1) {
                                    fact += ` and <a href="https://www.strava.com/segments/${element.segment}">${element.name}</a>`;
                                } else {
                                    fact += `<a href="https://www.strava.com/segments/${element.segment}">${element.name}</a>, `;
                                }
                            });
                            break;
                        case 'burroFact1':
                            fact = `Burros are a member of the horse family, Equidae. Originally from Africa, they were introduced to the Desert Southwest by the Spaniards in the 1500s. (The word “burro” is derived from the Spanish word “borrico,” meaning donkey.)`
                            break;
                        case 'crowns2022':
                            // most crowns in 2022
                            fact = `Most "fastest time of 2022" in ${areaname}: `;
                            const topCrowns2022 = mostFrequent(crowns2022, 1)
                            topCrowns2022.forEach((topAthlete, index) => {
                                const thisAthlete = athleteData.filter(athlete => athlete.id == topAthlete.id)[0];
                                if (topCrowns2022.length == 1) {
                                    fact += ` <a href="https://www.strava.com/athletes/${thisAthlete.id}/">${thisAthlete.name}</a> `;
                                    fact += `has ${topAthlete.count} crowns.`; //
                                } else {
                                    if (index == topCrowns2022.length - 1) {
                                        fact += ` and <a href="https://www.strava.com/athletes/${thisAthlete.id}/">${thisAthlete.name}</a>.`;
                                        fact += ` All ${topCrowns2022.length} have ${topAthlete.count} crowns.`; //
                                    } else {
                                        fact += `<a href="https://www.strava.com/segments/${thisAthlete.id}">${thisAthlete.name}</a>, `;
                                    }
                                }
                            });
                            break;
                        case 'crowns':
                            // most crowns overall
                            fact = `Most overall crowns in ${areaname}: `;
                            const topCrowns = mostFrequent(crowns, 1)
                            topCrowns.forEach((topAthlete, index) => {
                                const thisAthlete = athleteData.filter(athlete => athlete.id == topAthlete.id)[0];
                                if (topCrowns.length == 1) {
                                    fact += ` <a href="https://www.strava.com/athletes/${thisAthlete.id}/">${thisAthlete.name}</a> `;
                                    fact += `has ${topAthlete.count} crowns.`; //
                                } else {
                                    if (index == topCrowns.length - 1) {
                                        fact += ` and <a href="https://www.strava.com/athletes/${thisAthlete.id}/">${thisAthlete.name}</a>`;
                                        fact += `. All ${topCrowns.length} have ${topAthlete.count} crowns.`; //
                                    } else {
                                        fact += `<a href="https://www.strava.com/segments/${thisAthlete.id}">${thisAthlete.name}</a>, `;
                                    }
                                }
                            });
                            break;
                        case 'peopleWithCrowns':
                            const peopleWithCrowns = mostFrequent(crowns);
                            fact = `${peopleWithCrowns.length} different people have at least one crown in ${areaname}.`;
                            console.log("People with crowns:", peopleWithCrowns);
                            break;
                        case 'peopleWithCrowns2022':
                            const peopleWithCrowns2022 = mostFrequent(crowns2022);
                            fact = `${peopleWithCrowns2022.length} different people have a "fastest time of 2022" on at least one segment in ${areaname}.`;
                            console.log("Fastest time in 2022:", peopleWithCrowns2022);
                            break;
                        default:
                            // NEVER
                            console.log("Oh oh 103 should not happen");
                    }
                }
                const newDiv2 = document.createElement("li");
                newDiv2.innerHTML = fact;
                trivialistElement.prepend(newDiv2);
                return;
            } // end of getRandomFact

            function mostFrequent(items, k) {
                // from a comment in https://dev.to/alisabaj/finding-the-most-frequent-elements-in-an-array-10k2
                let lookup = {};
                let output = [];
                let itemCounter = 0;
                for (var i = 0; i < items.length; i++) {
                    // Have we seen this item before or not?
                    if (!lookup[items[i]]) {
                        // No? Ok, create an object in our lookup
                        // and set reference to it in our output array
                        lookup[items[i]] = { "count": 0, "id": items[i] };
                        output.push(lookup[items[i]]);
                        itemCounter++;
                    }
                    // Add one to the "count" attribute in our lookup
                    // which adds one to the count attribute in our "output" array
                    lookup[items[i]].count++;
                }
                // Bjorn - Sort descending, return all that has same count or more as top {{k}} results
                output.sort((a, b) => { return a.count > b.count ? -1 : 1 });
                if (!k) { k = output.length - 1 } // show all
                return output.filter(seg => seg.count >= output[k - 1].count);
            }

            function getFactByField(casenum, factField) {
                if (factField == "name") {
                    segmentData.sort((a, b) => {
                        return b[factField].length - a[factField].length;  // longest first
                    });
                } else if (factField == "distance") {
                    segmentData.sort((a, b) => {
                        return b[factField] - a[factField];  // longest first
                    });
                }
                if (casenum == 1) { // longest
                    const seg = segmentData[0];
                    if (factField == "name") {
                        if (segmentData[0][factField].length == segmentData[1][factField].length) { // multiple names with same length
                            return `The longest segment names are ${segmentData[0][factField].length} characters long:  <a href="https://www.strava.com/segments/${segmentData[0].segment}">${segmentData[0].name}</a> and  <a href="https://www.strava.com/segments/${segmentData[1].segment}">${segmentData[1].name}</a>`;
                        } else {
                            return `The longest segment name is ${seg[factField].length} characters long: <a href="https://www.strava.com/segments/${seg.segment}">${seg.name}</a>`;
                        }
                    } else if (factField == "distance") {
                        return `The very longest segment is ${seg[factField]} miles: <a href="https://www.strava.com/segments/${seg.segment}">${seg.name}</a>`;
                    } else {
                        console.log("OH OH")
                    }
                } else if (casenum == 2) { // 2nd longest
                    const seg = segmentData[1];
                    if (factField == "name") {
                        if (segmentData[0].name.length != segmentData[1].name.length) {
                            return `The second longest name is ${segmentData[1].name.length} characters long: <a href="https://www.strava.com/segments/${segmentData[1].segment}">${segmentData[1].name}</a>`;
                        } else {
                            const result = names.filter(name => name.match(/Hulda/));
                            return result.length + " segment names contain the word Hulda!";
                        }
                    } else if (factField == "distance") {
                        return `The second longest segment is ${seg[factField]} miles: <a href="https://www.strava.com/segments/${seg.segment}">${seg.name}</a>`;
                    }
                } else if (casenum == 3) { // shortest
                    segmentData.reverse();
                    const seg0 = segmentData[0];
                    const seg1 = segmentData[1];
                    if (factField == "name") {
                        if (seg0.name.length == seg1.name.length) { // multiple names with same length
                            return `The shortest segment names are only ${seg0.name.length} characters long:  <a href="https://www.strava.com/segments/${seg0.segment}">${seg0.name}</a> and <a href="https://www.strava.com/segments/${seg1.segment}">${seg1.name}</a>`;
                        } else {
                            return `The shortest segment name is only ${seg0.name.length} characters long: <a href="https://www.strava.com/segments/${seg0.segment}">${seg0.name}</a>`;
                        }
                    } else if (factField == "distance") {
                        if (segmentData[0][factField] == segmentData[1][factField]) { // multiples with same
                            return `The shortest segments are ${seg0[factField]} miles: <a href="https://www.strava.com/segments/${seg0.segment}">${seg0.name}</a> and <a href="https://www.strava.com/segments/${seg1.segment}">${seg1.name}</a>`;
                        } else {
                            return `The shortest segment is ${seg0[factField]} miles: <a href="https://www.strava.com/segments/${seg0.segment}">${seg0.name}</a>`;
                        }
                    }
                } else if (casenum == 4) { // 2nd shortest
                    segmentData.reverse();
                    const seg = segmentData[1];
                    if (factField == "name") {
                        if (segmentData[0].name.length != segmentData[1].name.length) {
                            return `The second shortest name is ${seg.name.length} characters long: <a href="https://www.strava.com/segments/${seg.segment}">${seg.name}</a>`;
                        } else {
                            const result = names.filter(name => name.match(/hulda/));
                            return result.length + " segment names contain the word hulda!";
                        }
                    } else if (factField == "distance") {
                        return `The second shortest segment is ${seg[factField]} miles: <a href="https://www.strava.com/segments/${seg.segment}">${seg.name}</a>`;
                    }
                } else {
                    return "Hmm, maybe you should go run now?"
                }
            } // end of getFactByField

            const findAverageDistance = (arr) => {
                const { length } = arr;
                return arr.reduce((acc, val) => {
                    return acc + (val.distance / length);
                }, 0).toFixed(2);
            };

            const findAverageNameLength = (arr) => {
                const { length } = arr;
                return arr.reduce((acc, val) => {
                    return acc + (val.name.length / length);
                }, 0).toFixed(1);
            };

            getRandomFact(); // first fact
        })();
        // END TRIVIA
    </script>
    <hr>
</body>

</html>

<!--
    for (let seg of segmentData) {
        console.log(`${seg.name.length} \t ${seg.name} `);
        //break; // possible in for loop, but not foreach loop
    }
-->